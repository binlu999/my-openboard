{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Effect, ofType } from \"@ngrx/effects\";\nimport { of } from \"rxjs\";\nimport { catchError, map, switchMap, tap } from \"rxjs/operators\";\nimport { environment } from \"src/environments/environment\";\nimport { User } from \"../user.model\";\nimport { AuthAuthencated, AuthAuthencateFail, AUTH_AUTHENCATED, AUTH_AUTO_LOGIN, AUTH_LOGIN_START, AUTH_LOGOUT, AUTH_SIGNUP_START } from \"./auth.action\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"@angular/common/http\";\nimport * as i3 from \"@angular/router\";\nimport * as i4 from \"../auth.service\";\n\nconst handleAuthencation = (email, id, token, expiredIn) => {\n  const expirationData = new Date(new Date().getTime() + +expiredIn * 1000);\n  const user = new User(email, id, token, expirationData);\n  localStorage.setItem(environment.AUTH_SEC_TOKEN_NAME, JSON.stringify(user));\n  return new AuthAuthencated({\n    email: email,\n    id: id,\n    token: token,\n    tokenExpirationDate: expirationData,\n    redirect: true\n  });\n};\n\nconst handleError = errorResp => {\n  let errorMessage = \"Unknown error occured!\";\n\n  if (!errorResp.error || !errorResp.error.error) {\n    return of(new AuthAuthencateFail(errorMessage));\n  }\n\n  switch (errorResp.error.error.message) {\n    case 'EMAIL_EXISTS':\n      errorMessage = \"Email already exist!\";\n      break;\n\n    case 'EMAIL_NOT_FOUND':\n      errorMessage = \"Invalid email address!\";\n      break;\n\n    case \"INVALID_PASSWORD\":\n      errorMessage = \"Invalid password!\";\n      break;\n\n    default:\n      break;\n  }\n\n  return of(new AuthAuthencateFail(errorMessage));\n};\n\nexport class AuthEffects {\n  constructor(actions$, http, router, authService) {\n    this.actions$ = actions$;\n    this.http = http;\n    this.router = router;\n    this.authService = authService;\n    this.authSignup = this.actions$.pipe(ofType(AUTH_SIGNUP_START), switchMap(signupData => {\n      return this.http.post(environment.AUTH_SIGNUP_URL + environment.AUTH_API_KEY, {\n        email: signupData.payload.email,\n        password: signupData.payload.password,\n        returnSecureToken: true\n      }).pipe(tap(respData => {\n        this.authService.setLogoutTimer(+respData.expiresIn * 1000);\n      }), map(respData => {\n        return handleAuthencation(respData.email, respData.localId, respData.idToken, respData.expiresIn);\n      }), catchError(errorResp => {\n        return handleError(errorResp);\n      }));\n    }));\n    this.authLogin = this.actions$.pipe(ofType(AUTH_LOGIN_START), switchMap(authData => {\n      return this.http.post(environment.AUTH_SIGNIN_URL + environment.AUTH_API_KEY, {\n        email: authData.payload.email,\n        password: authData.payload.password,\n        returnSecureToken: true\n      }).pipe(tap(respData => {\n        this.authService.setLogoutTimer(+respData.expiresIn * 1000);\n      }), map(respData => {\n        return handleAuthencation(respData.email, respData.localId, respData.idToken, respData.expiresIn);\n      }), catchError(errorResp => {\n        return handleError(errorResp);\n      }));\n    }));\n    this.authAutoLogin = this.actions$.pipe(ofType(AUTH_AUTO_LOGIN), map(() => {\n      const user = JSON.parse(localStorage.getItem(environment.AUTH_SEC_TOKEN_NAME));\n\n      if (!user) {\n        return {\n          type: 'DUMMY'\n        };\n      }\n\n      const loggedInUser = new User(user.email, user.Id, user._token, new Date(user._tokenExpirationDate));\n\n      if (loggedInUser.token) {\n        console.log('Auto');\n        const expiredIn = new Date(user._tokenExpirationDate).getTime() - new Date().getTime();\n        this.authService.setLogoutTimer(expiredIn);\n        return new AuthAuthencated({\n          email: loggedInUser.email,\n          id: loggedInUser.Id,\n          token: loggedInUser.token,\n          tokenExpirationDate: new Date(user._tokenExpirationDate),\n          redirect: false\n        });\n      } else {\n        return {\n          type: 'DUMMY'\n        };\n      }\n    }));\n    this.authencatedRedirect = this.actions$.pipe(ofType(AUTH_AUTHENCATED), tap(authAuthencated => {\n      if (authAuthencated.payload.redirect) this.router.navigate(['/']);\n    }));\n    this.logoutRedirect = this.actions$.pipe(ofType(AUTH_LOGOUT), tap(() => {\n      this.authService.clearLogoutTimer();\n      localStorage.removeItem(environment.AUTH_SEC_TOKEN_NAME);\n      this.router.navigate(['/auth']);\n    }));\n  }\n\n}\n\nAuthEffects.ɵfac = function AuthEffects_Factory(t) {\n  return new (t || AuthEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.HttpClient), i0.ɵɵinject(i3.Router), i0.ɵɵinject(i4.AuthService));\n};\n\nAuthEffects.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AuthEffects,\n  factory: AuthEffects.ɵfac\n});\n\n__decorate([Effect()], AuthEffects.prototype, \"authSignup\", void 0);\n\n__decorate([Effect()], AuthEffects.prototype, \"authLogin\", void 0);\n\n__decorate([Effect()], AuthEffects.prototype, \"authAutoLogin\", void 0);\n\n__decorate([Effect({\n  dispatch: false\n})], AuthEffects.prototype, \"authencatedRedirect\", void 0);\n\n__decorate([Effect({\n  dispatch: false\n})], AuthEffects.prototype, \"logoutRedirect\", void 0);","map":null,"metadata":{},"sourceType":"module"}